#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 20, 2023 06:40:26 PM +07  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from PIL import Image, ImageTk
from datetime import datetime
import ipaddress
import struct
import socket
import re
import string
import codecs
import random
import binascii
import os
import time
import threading

import aprstday

_debug = True # False to eliminate debug printing from callback functions.
msgid_list = ['5859', '595A', '5253', '4D4E', '4B4A']
my_bcn="c000A0B29692A6A6e0b288608486b06eae92888a62406303f021303631302e3834532f31303635312e3639452d594430424358277320415052532076696120505954484f4ec0"
s_strbcn = ''
s_strack = ''
s_strmsg = ''
connected = "no"
s = socket.socket()
polledData = ''

call_src = 'YD0BCX-7'
call_dst = 'PYKISS'
ssid_src = ''
ssid_dst = ''
kiss_preamble = "C000"
pathctrlpid = "ae92888a62406303f0"
#uitxt = "!0610.84S/10651.69E-YD0BCX's APRS via PYTHON"

stop_event = threading.Event()

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    cwd = os.getcwd()
    os.chdir(cwd)
    # Load the icon
    icon = Image.open("Oxygen.ico")
    icon = ImageTk.PhotoImage(icon)
    
    # Set the window icon
    root.iconphoto(True, icon)
    
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = aprstday.TopLevel1(_top1)
    #root.after(1, task)
    root.mainloop()

def Connect(*args):
    #if _debug:
    #    print('aprstday_support.Connect')
    #    for arg in args:
    #        print ('    another arg:', arg)
    #    sys.stdout.flush()
    try:
        s_ipv4 = str(ipaddress.ip_address(_w1.TextKissIp.get("1.0",'end-1c')))
    except ValueError:
        s_ipv4 = "Wrong ipv4 format"
    if s_ipv4:
        _w1.Text1.insert('1.0', dtime() + "IP: " + s_ipv4 + "\n")

    try:
        s_port = _w1.TextKissPort.get("1.0",'end-1c')
        s_port = int(s_port)
    except:
        s_port = 8001

    if _w1.TextKissIp.get("1.0",'end-1c') and _w1.TextKissPort.get("1.0",'end-1c'):
        s = sockconnect(s_ipv4, s_port)
        return s
    else:
        pass

def sockconnect(s_ipv4, s_port):
    global s, connected, threadpoll, threadbcn
    if connected == "no":
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        try:
            s.connect((s_ipv4, s_port))
        except socket.error:
            _w1.Text1.insert('1.0', dtime() + "Caught exception socket.errors")
        _w1.Text1.insert('1.0', dtime() + "CONNECTED to, IP " + s_ipv4 + " PORT: " + str(s_port) + "\n")
        _w1.Button1.configure(text='''Disconnect''')
        connected = "yes"
        stop_event.clear()
    elif connected == "yes":
        _w1.Button1.configure(text='''Connect''')
        _w1.Text1.insert('1.0', dtime() + "DISCONNECTED\n")
        connected = "no"
        stop_event.set()
    threadpoll = threading.Thread(target=polling)
    threadbcn = threading.Thread(target=sendbcn)
    threadpoll.daemon = True
    threadbcn.daemon = True
    threadpoll.start()
    threadbcn.start()
    threadpoll.priority = 1
    threadbcn.priority = 1
    return (s, connected)

def SendMesg(*args):
    #if _debug:
    #    print('aprstday_support.SendMesg')
    #    for arg in args:
    #        print ('    another arg:', arg)
    #    sys.stdout.flush()
    global s, connected, s_strbcn, call_src, call_dst, ssid_src, ssid_dst, s_strmsg
    # srcarg = call_src
    # dstarg = call_dst
    if _w1.TextBeacon.get("1.0",'end-1c'):
        srcarg = "YD0BCX-7"
        dstarg = "PYKISS"
        uitxt = _w1.TextBeacon.get("1.0",'end-1c')
        if srcarg.find('-') != -1:
            srcarg = srcarg.split("-")
            call_src = srcarg[0]
            ssid_src = srcarg[1]
        else:
            call_src = call_src
            ssid_src = "40"
        if dstarg.find('-') != -1:
            dstarg = dstarg.split("-")
            call_dst = dstarg[0]
            ssid_dst = dstarg[1]
        else:
            call_dst = call_dst
            ssid_dst = "E0"
        if dstarg:
            if ssid_src != "40":
                decimal_value_src = int(ssid_src)
                hexadecimal_value_src = decimal_to_hex(decimal_value_src)
                encoded_ssid_src = hexadecimal_value_src[2:]
            else:
                encoded_ssid_src  = "40"
            if ssid_dst != "E0":
                decimal_value_dst = int(ssid_dst)
                hexadecimal_value_dst = decimal_to_hex(decimal_value_dst)
                encoded_ssid_dst = hexadecimal_value_dst[2:]
            else:
                encoded_ssid_dst = "E0"

        encoded_src = encode_addr(call_src)
        encoded_dst = encode_addr(call_dst)
        uiframe = decode_8bit_txt(uitxt)
        complete_frame = kiss_preamble.upper() + encoded_dst.upper() + encoded_ssid_dst.upper() + encoded_src.upper() + encoded_ssid_src.upper() + pathctrlpid.upper() + uiframe.upper() + "C0"
        _w1.Text1.insert('1.0', dtime() + complete_frame + "\n")
        s_strbcn=bytes.fromhex(complete_frame)
        try:
            s.sendall(s_strbcn)
        except:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.sendall(s_strbcn)
            connected = "yes"
        return
    if _w1.TextMessages.get("1.0",'end-1c'):
        srcarg = "YD0BCX-7"
        dstarg = "PYKISS"
        msgid=random.choice(msgid_list)
        uitxt = _w1.TextMessages.get("1.0",'end-1c')
        if srcarg.find('-') != -1:
            srcarg = srcarg.split("-")
            call_src = srcarg[0]
            ssid_src = srcarg[1]
        else:
            call_src = call_src
            ssid_src = "40"
        if dstarg.find('-') != -1:
            dstarg = dstarg.split("-")
            call_dst = dstarg[0]
            ssid_dst = dstarg[1]
        else:
            call_dst = call_dst
            ssid_dst = "E0"
        if dstarg:
            if ssid_src != "40":
                decimal_value_src = int(ssid_src)
                hexadecimal_value_src = decimal_to_hex(decimal_value_src)
                encoded_ssid_src = hexadecimal_value_src[2:]
            else:
                encoded_ssid_src  = "40"
            if ssid_dst != "E0":
                decimal_value_dst = int(ssid_dst)
                hexadecimal_value_dst = decimal_to_hex(decimal_value_dst)
                encoded_ssid_dst = hexadecimal_value_dst[2:]
            else:
                encoded_ssid_dst = "E0"

        encoded_src = encode_addr(call_src)
        encoded_dst = encode_addr(call_dst)
        uiframe = decode_8bit_txt(uitxt)
        complete_frame = kiss_preamble.upper() + encoded_dst.upper() + encoded_ssid_dst.upper() + encoded_src.upper() + encoded_ssid_src.upper() + pathctrlpid.upper() + uiframe.upper() + "7B"+ msgid.upper() + "7DC0"
        _w1.Text1.insert('1.0', dtime() + complete_frame + "\n")
        s_strmsg=bytes.fromhex(complete_frame)
        try:
            s.sendall(s_strmsg)
        except:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.sendall(s_strmsg)
            connected = "yes"
        return

decimal_to_hex_map = {
    0: '0x60', 1: '0x62', 2: '0x64', 3: '0x66',
    4: '0x68', 5: '0x6A', 6: '0x6C', 7: '0x6E',
    8: '0x70', 9: '0x72', 10: '0x75', 11: '0x77',
    12: '0x79', 13: '0x7B', 14: '0x7D', 15: '0x7F'
}

def encode_addr(data):
    #bytes-like sting
    frame = bytes(data, 'utf-8')
    (a1, a2, a3, a4, a5, a6) = struct.unpack("<BBBBBB", frame[0:6])
    addr = str(hex(a1 << 1) + hex(a2 << 1) + hex(a3 << 1) + hex(a4 << 1) + hex(a5 << 1) + hex(a6 << 1)).replace("0x", "")
    return addr

def decode_8bit_txt(ui):
    hs = ''
    ascii_str = ui.replace("\\", "")
    #print((ascii_str))
    for i in ascii_str:
        c = hex(ord(i))
        hs += c
    return hs.replace("0x", "")

def decimal_to_hex(decimal_value):
    return decimal_to_hex_map.get(decimal_value, 'Invalid')

def decode_addr(data, cursor):
    (a1, a2, a3, a4, a5, a6, a7) = struct.unpack("<BBBBBBB", data[cursor:cursor+7])
    hrr = a7 >> 5
    ssid = (a7 >> 1) & 0x0f
    ext = a7 & 0x1

    addr = struct.pack("<BBBBBB", a1 >> 1, a2 >> 1, a3 >> 1, a4 >> 1, a5 >> 1, a6 >> 1)
    if ssid != 0:
      call = "{}-{}".format(addr.strip(), ssid)
    else:
      call = addr
    call = str(call).replace("'", "").replace("b", "")
    return (call, hrr, ext)

def decode_uframe(ctrl, data, pos):
    #print("U Frame")
    if ctrl == 0x3:
        # UI frame
        #pid = data[pos]
        #(pid,) = struct.unpack("<B", data[pos])
        (pid,) = bytes([struct.unpack("<B", data[pos:pos+1])[0]])
        pos += 1
        rem = len(data[pos:-2])
        info = data[pos:]
        #info = struct.unpack("<" + "B"*rem, data[pos:-2])
        pos += rem
        #fcs = struct.unpack("<BB", data[pos:pos+2])
        fcs = struct.unpack("<BB", data[pos:])
        finfo = str(info).replace("\\xc0", "")
        fpid = str(hex(pid)).upper()
    return (fpid, finfo, fcs)

def decode_sframe(ctrl, data, pos):
    #print("S Frame")
    _w1.Text1.insert('1.0', dtime() + "S Frame\n")

def decode_iframe(ctrl, data, pos):
    #print("I Frame")
    _w1.Text1.insert('1.0', dtime() + "I Frame\n")

def find_src(my_str):
    test_str = my_str

    # initializing substrings
    sub1 = "}"
    sub2 = ">"

    # getting index of substrings
    try:
       idx1 = test_str.index(sub1)
    except ValueError:
       idx1 = -1
    try:
       idx2 = test_str.index(sub2)
    except ValueError:
        idx2 = -1
    if idx1 != -1 and idx2 != -1:
       res = ''
       # getting elements in between
       for idx in range(idx1 + len(sub1), idx2):
           res = res + test_str[idx]
       return res
    else:
       return
def polling():
    global s, connected, polledData, s_strbcn, s_strack
    DTI=':! :/ :< := :> :; :} :{'
    while not stop_event.is_set():
        try:
            polledData = s.recv(1024)
        except:
            pass
        frame = polledData
        if frame:
            _w1.Text1.insert('1.0', dtime() + str(polledData) + "\n")

            #def p(frame):
            pos = 2

            # DST
            try:
                (dest_addr, dest_hrr, dest_ext) = decode_addr(frame, pos)
            except:
                pass
            #print("DST: " + dest_addr)
            _w1.Text1.insert('1.0', dtime() + "DST: " + dest_addr + "\n")

            # SRC
            try:
                (src_addr, src_hrr, src_ext) = decode_addr(frame, pos+7)
            except:
                pass
            #print("SRC: " + src_addr)
            _w1.Text1.insert('1.0', dtime() + "SRC: " + src_addr + "\n")

            # REPEATERS
            ext = src_ext
            while ext == 0:
                rpt_addr, rpt_hrr, ext = decode_addr(frame, pos)
                #print("RPT: " + rpt_addr)
                _w1.Text1.insert('1.0', dtime() + "RPT: " + rpt_addr + "\n")
                pos += 7

            # CTRL
            ctrl = frame[pos]
            #print(ctrl)
            pos += 1
            #print(pos)

            if (ctrl & 0x3) == 0x3:
                _w1.Text1.insert('1.0', dtime() + "U Frame\n")
                _w1.Text1.insert('1.0', dtime() + "CTRL: " + f'0x{ctrl:02x}' + "\n")
                (pid, info, fcs) = decode_uframe(ctrl, frame, pos)
                _w1.Text1.insert('1.0', dtime() + "PID: " + str(pid) + "\n")
                info = info[:-1].replace("b'", "", 1).replace("b\"", "", 1)
                _w1.Text1.insert('1.0', dtime() + "INFO: " + info + "\n")
                (msbbit, lsbbit) = fcs
                src_address=find_src(info)
                try:
                    src_address=f"{src_address:9}".format(src_address)
                except TypeError:
                    src_address=''
                _w1.Text1.insert('1.0', dtime() + src_address  + "\n")

                src_addressack = src_address + ":ack"

                if ':}' in info:
                    idxpload=info.find("}")
                    if idxpload != -1:
                        _w1.Text1.insert('1.0', dtime() + info[idxpload+1:] + "\n")

                if '::' in info:
                    idxack=info.rfind("{")
                    if idxack != -1:
                        _w1.Text1.insert('1.0', dtime() + info[idxack+1:] + "\n")

                    if idxack != -1 and src_address:
                        _w1.Text1.insert('1.0', dtime() + "ACK: " + info[idxack+1:] + "\n")
                        ackd=info[idxack+1:]
                        strack=ackd.encode("utf-8").hex()
                        srcaddr=src_addressack.encode("utf-8").hex()
                        s_strack=bytes.fromhex("c000A0B29692A6A6e0b288608486b06eae92888a62406303f03A" + srcaddr + strack + "C0")
                        _w1.Text1.insert('1.0', dtime() + "Send ACK: :" +  src_addressack + ackd + "\n")
                        try:
                            s.sendall(s_strack)
                        except:
                            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                            s.sendall(s_strack)
                            connected = "yes"

            elif (ctrl & 0x3) == 0x1:
                decode_sframe(ctrl, frame, pos)
            elif (ctrl & 0x1) == 0x0:
                decode_iframe(ctrl, frame, pos)
            time.sleep(1)  # Sleep for 1 second to reduce CPU usage

        else:
            pass

def sendbcn():
    global s, connected, s_strbcn
    old_t=time.time()
    while not stop_event.is_set():
        bcnInterval = _w1.TextBeaconInterval.get("1.0",'end-1c')
        try:
            bcnInterval = int(bcnInterval)
        except:
            bcnInterval = 300

        if time.time()-old_t > bcnInterval:
            s_strbcn=bytes.fromhex(my_bcn)
            _w1.Text1.insert('1.0', dtime() + "beacon position: " +  binascii.unhexlify("21303631302e3834532f31303635312e3639452d594430424358277320415052532076696120505954484f4e").decode('utf8') + "\n")
            _w1.Text1.insert('1.0', dtime() + "Beacon Interval: " + str(bcnInterval)  + "\n")
            try:
                s.sendall(s_strbcn)
            except:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.sendall(s_strbcn)
                connected = "yes"
            old_t=time.time()
        time.sleep(1)  # Sleep for 1 second to reduce CPU usage

def dtime():
    now = datetime.now()
    s1 = now.strftime("%m/%d/%Y, %H:%M:%S")
    return ("[" + str(s1) + "] ")

#def task():
#    root.after(1, task)

if __name__ == '__main__':
    aprstday.start_up()

